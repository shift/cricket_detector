<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Advanced Beep Detector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; touch-action: manipulation; }
        .amp-bar-container { background-color: #374151; }
        .amp-bar { background: linear-gradient(90deg, #10B981 0%, #F59E0B 70%, #EF4444 100%); transition: width 0.3s ease-in-out; }
        #radarCanvas { background-color: #1f2937; }
        .modal-backdrop { backdrop-filter: blur(4px); }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl bg-gray-800 rounded-2xl shadow-lg p-6 md:p-8 space-y-6 relative">
        <!-- Language Switcher -->
        <div class="absolute top-4 right-6">
            <select id="languageSwitcher" class="bg-gray-700 text-white text-sm rounded-md p-1 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                <option value="en">English</option>
                <option value="de">Deutsch</option>
            </select>
        </div>

        <div class="text-center">
            <h1 class="text-3xl font-bold text-blue-400" data-lang="title">Advanced Detector</h1>
            <p class="text-gray-400 mt-2" data-lang="subtitle">Signal analysis and tracking tool.</p>
        </div>

        <!-- Controls -->
        <div class="space-y-4 p-4 bg-gray-900/50 rounded-lg">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                 <button id="startButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300" data-lang="startDetection">
                    Start Detection
                </button>
                 <button id="analyzeHistoryButton" disabled class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 px-6 rounded-lg transition-all duration-300 disabled:bg-gray-600 disabled:cursor-not-allowed" data-lang="analyze">
                    Heard It! Analyze Last 5s
                </button>
            </div>
        </div>
        
        <!-- Active Targets UI -->
        <div class="space-y-2 p-3 bg-gray-900/50 rounded-lg">
            <h3 class="text-lg font-medium text-gray-300 text-center" data-lang="activeTargets">Active Targets</h3>
            <div id="targetsContainer" class="flex flex-wrap gap-2 justify-center">
                <!-- Tracked frequencies will be injected here -->
            </div>
        </div>

        <!-- Direction Finder -->
        <div class="space-y-3 mt-6">
             <h2 class="text-xl font-bold text-gray-300 text-center" data-lang="directionFinder">Direction Finder</h2>
            <div class="w-full aspect-square rounded-full mx-auto max-w-xs shadow-lg mt-2">
                <canvas id="radarCanvas"></canvas>
            </div>
             <div id="compassStatus" class="text-center text-sm text-gray-400 mt-2" data-lang="compassInactive">Compass not initialized.</div>
        </div>

        <!-- Detection Log -->
        <div class="space-y-3 mt-6">
            <div class="flex justify-between items-center">
                 <h2 class="text-xl font-bold text-gray-300" data-lang="detectionLog">Detection Log</h2>
                 <button id="clearLogButton" class="text-sm text-gray-400 hover:text-white" data-lang="clear">Clear</button>
            </div>
            <div id="logContainer" class="w-full h-48 bg-gray-900/50 rounded-lg p-3 space-y-2 overflow-y-auto">
                <p id="logPlaceholder" class="text-gray-500 text-center pt-4" data-lang="waiting">Waiting for detections...</p>
            </div>
        </div>
    </div>

    <!-- Analysis Modal -->
    <div id="analysisModal" class="fixed inset-0 z-50 items-center justify-center hidden">
        <div class="modal-backdrop fixed inset-0 bg-black/50"></div>
        <div class="relative bg-gray-800 rounded-2xl shadow-xl w-full max-w-lg m-4 p-6">
            <h2 class="text-2xl font-bold text-blue-400 mb-4" data-lang="modalTitle">Look-back Analysis</h2>
            <p class="text-gray-400 mb-4" data-lang="modalSubtitle">Click on a vertical slice in the spectrogram to analyze a moment in time.</p>
            <div class="bg-gray-900 rounded-lg overflow-hidden relative">
                <canvas id="spectrogramCanvas"></canvas>
                <div id="spectrogramSelector" class="absolute top-0 h-full w-1 bg-teal-400/50 hidden"></div>
            </div>
            <div id="peakInfo" class="mt-4 text-center hidden">
                <p class="text-lg font-bold text-teal-300" data-lang="modalPeakTitle">Sound Signature at Selected Moment:</p>
                <div id="peakList" class="my-2 text-sm text-gray-300"></div>
                <div class="flex gap-4 justify-center mt-4">
                    <button id="playSignatureButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg" data-lang="replaySound">Replay Sound</button>
                    <button id="trackSignatureButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg" data-lang="trackSignature">Track this Signature</button>
                </div>
            </div>
            <button id="closeModalButton" class="absolute top-4 right-4 text-gray-400 hover:text-white">&times;</button>
        </div>
    </div>

    <!-- SCRIPT LOADING -->
    <script>
        function startApp(Module) {
            // DOM Elements
            const startButton = document.getElementById('startButton'), analyzeHistoryButton = document.getElementById('analyzeHistoryButton'), clearLogButton = document.getElementById('clearLogButton'), logContainer = document.getElementById('logContainer'), logPlaceholder = document.getElementById('logPlaceholder'), targetsContainer = document.getElementById('targetsContainer'), languageSwitcher = document.getElementById('languageSwitcher'), compassStatusEl = document.getElementById('compassStatus'), radarCanvas = document.getElementById('radarCanvas'), radarCtx = radarCanvas.getContext('2d');
            const analysisModal = document.getElementById('analysisModal'), closeModalButton = document.getElementById('closeModalButton'), spectrogramCanvas = document.getElementById('spectrogramCanvas'), spectrogramCtx = spectrogramCanvas.getContext('2d'), spectrogramSelector = document.getElementById('spectrogramSelector'), peakInfo = document.getElementById('peakInfo'), peakListEl = document.getElementById('peakList'), playSignatureButton = document.getElementById('playSignatureButton'), trackSignatureButton = document.getElementById('trackSignatureButton');

            // App State
            let audioContext, analyser, detectorPtr, dataPtr, liveFreqPtr, targetsPtr;
            let animationFrameId, selectedSignature = [], currentHeading = null;
            let compassInitialized = false;
            const detectionLog = [], historyBuffer = [], HISTORY_SIZE = 300;
            let TARGET_FREQUENCIES;
            const SENSITIVITY = 190;

            const wasmModule = Module;
            detectorPtr = wasmModule._detector_new();
            const bufferSize = 2048;
            dataPtr = wasmModule._malloc(bufferSize * Uint8Array.BYTES_PER_ELEMENT);
            liveFreqPtr = wasmModule._malloc(4);

            // --- Internationalization (i18n) ---
            const translations = {
                en: {
                    title: "Advanced Detector",
                    subtitle: "Signal analysis and tracking tool.",
                    startDetection: "Start Detection",
                    stopDetection: "Stop Detection",
                    analyze: "Heard It! Analyze Last 5s",
                    activeTargets: "Active Targets",
                    detectionLog: "Detection Log",
                    directionFinder: "Direction Finder",
                    clear: "Clear",
                    waiting: "Waiting for detections...",
                    modalTitle: "Look-back Analysis",
                    modalSubtitle: "Click on a vertical slice in the spectrogram to analyze a moment in time.",
                    modalPeakTitle: "Sound Signature at Selected Moment:",
                    replaySound: "Replay Sound",
                    trackSignature: "Track this Signature",
                    noPeaks: "No significant peaks found.",
                    compassInactive: "Compass not initialized.",
                    compassNoSupport: "Compass not available on this device.",
                    pointing: "Pointing"
                },
                de: {
                    title: "Erweiterter Detektor",
                    subtitle: "Signalanalyse- und Tracking-Tool.",
                    startDetection: "Erkennung starten",
                    stopDetection: "Erkennung stoppen",
                    analyze: "Gehört! Letzte 5s analysieren",
                    activeTargets: "Aktive Ziele",
                    detectionLog: "Erkennungsprotokoll",
                    directionFinder: "Richtungssucher",
                    clear: "Löschen",
                    waiting: "Warte auf Erkennungen...",
                    modalTitle: "Rückblick-Analyse",
                    modalSubtitle: "Klicken Sie auf einen vertikalen Bereich im Spektrogramm, um einen Zeitpunkt zu analysieren.",
                    modalPeakTitle: "Klangsignatur im ausgewählten Moment:",
                    replaySound: "Ton wiedergeben",
                    trackSignature: "Diese Signatur verfolgen",
                    noPeaks: "Keine signifikanten Spitzen gefunden.",
                    compassInactive: "Kompass nicht initialisiert.",
                    compassNoSupport: "Kompass auf diesem Gerät nicht verfügbar.",
                    pointing: "Richtung"
                }
            };

            function setLanguage(lang) {
                document.querySelectorAll('[data-lang]').forEach(el => {
                    const key = el.getAttribute('data-lang');
                    if (translations[lang] && translations[lang][key]) {
                        el.textContent = translations[lang][key];
                    }
                });
                localStorage.setItem('detector_language', lang);
                languageSwitcher.value = lang;
            }

            languageSwitcher.addEventListener('change', (e) => setLanguage(e.target.value));
            
            // --- Frequency Management ---
            function loadTrackedFrequencies() {
                const defaultFrequencies = [4000.0, 5000.0, 12000.0];
                let savedFrequencies = [];
                try {
                    const stored = localStorage.getItem('trackedFrequencies');
                    if (stored) savedFrequencies = JSON.parse(stored);
                } catch (e) {
                    console.error("Could not parse saved frequencies:", e);
                    localStorage.removeItem('trackedFrequencies');
                }
                const allFrequencies = [...new Set([...defaultFrequencies, ...savedFrequencies])];
                TARGET_FREQUENCIES = new Float32Array(allFrequencies);
            }

            function saveTrackedFrequencies() {
                const userFrequencies = Array.from(TARGET_FREQUENCIES).filter(f => ![4000, 5000, 12000].includes(f));
                localStorage.setItem('trackedFrequencies', JSON.stringify(userFrequencies));
            }

            function updateWasmTargets() {
                if (targetsPtr) wasmModule._free(targetsPtr);
                targetsPtr = wasmModule._malloc(TARGET_FREQUENCIES.byteLength);
                wasmModule.HEAPF32.set(TARGET_FREQUENCIES, targetsPtr / Float32Array.BYTES_PER_ELEMENT);
                updateTargetsUI();
            }

            function updateTargetsUI() {
                targetsContainer.innerHTML = '';
                TARGET_FREQUENCIES.forEach(freq => {
                    const badge = document.createElement('span');
                    badge.className = 'bg-blue-600 text-white text-xs font-semibold mr-2 px-2.5 py-0.5 rounded-full flex items-center';
                    badge.innerHTML = `${(freq / 1000).toFixed(1)} kHz`;
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'ml-2 text-blue-200 hover:text-white';
                    removeBtn.innerHTML = '&times;';
                    removeBtn.onclick = () => {
                        TARGET_FREQUENCIES = new Float32Array(Array.from(TARGET_FREQUENCIES).filter(f => f !== freq));
                        saveTrackedFrequencies();
                        updateWasmTargets();
                    };
                    badge.appendChild(removeBtn);
                    targetsContainer.appendChild(badge);
                });
            }
            
            // --- Initialization ---
            const savedLang = localStorage.getItem('detector_language') || 'en';
            setLanguage(savedLang);
            loadTrackedFrequencies();
            updateWasmTargets();
            console.log("WASM module initialized and app started.");

            // --- Control Logic ---
            startButton.addEventListener('click', async () => {
                if (startButton.dataset.running === 'true') stopDetection();
                else await startDetection();
            });

            analyzeHistoryButton.addEventListener('click', showAnalysisModal);
            closeModalButton.addEventListener('click', () => analysisModal.style.display = 'none');
            analysisModal.querySelector('.modal-backdrop').addEventListener('click', () => analysisModal.style.display = 'none');
            
            clearLogButton.addEventListener('click', () => {
                detectionLog.length = 0;
                updateLogUI();
                drawRadar();
            });

            async function startDetection() {
                if (!compassInitialized) initializeCompass();
                if (!wasmModule) return;
                if (!audioContext) await setupAudio();
                if (audioContext.state === 'suspended') await audioContext.resume();
                startButton.dataset.running = 'true';
                startButton.textContent = translations[languageSwitcher.value].stopDetection;
                analyzeHistoryButton.disabled = false;
                recordAndDetect();
            }

            function stopDetection() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                if (audioContext) audioContext.suspend();
                startButton.dataset.running = 'false';
                startButton.textContent = translations[languageSwitcher.value].startDetection;
                analyzeHistoryButton.disabled = true;
            }

            async function setupAudio() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = bufferSize;
                    analyser.smoothingTimeConstant = 0.1;
                    const source = audioContext.createMediaStreamSource(stream);
                    source.connect(analyser);
                } catch (err) { console.error("Mic Error:", err); }
            }

            // --- Auto-Compass Initialization ---
            function initializeCompass() {
                if (compassInitialized) return;
                compassInitialized = true; // Attempt only once

                const handleOrientation = (event) => {
                    let heading = event.webkitCompassHeading || event.alpha;
                    if (heading !== null && typeof heading !== 'undefined') {
                        currentHeading = heading;
                        compassStatusEl.textContent = `${translations[languageSwitcher.value].pointing}: ${Math.round(currentHeading)}°`;
                    }
                };
                
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // iOS 13+
                    DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                window.addEventListener('deviceorientation', handleOrientation);
                            } else {
                                compassStatusEl.textContent = translations[languageSwitcher.value].compassNoSupport;
                            }
                        }).catch(() => {
                            compassStatusEl.textContent = translations[languageSwitcher.value].compassNoSupport;
                        });
                } else if ('ondeviceorientation' in window) {
                    // Other devices
                    window.addEventListener('deviceorientation', handleOrientation);
                    // Check if the event ever fires
                    setTimeout(() => {
                        if (currentHeading === null) {
                             compassStatusEl.textContent = translations[languageSwitcher.value].compassNoSupport;
                        }
                    }, 2000);
                } else {
                    compassStatusEl.textContent = translations[languageSwitcher.value].compassNoSupport;
                }
            }

            function recordAndDetect() {
                if (!analyser || !wasmModule) return;
                animationFrameId = requestAnimationFrame(recordAndDetect);
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArray);
                historyBuffer.push(new Uint8Array(dataArray));
                if (historyBuffer.length > HISTORY_SIZE) historyBuffer.shift();
                wasmModule.HEAPU8.set(dataArray, dataPtr);
                const detectedAmplitude = wasmModule._detector_find_multiple_peaks(detectorPtr, dataPtr, bufferLength, audioContext.sampleRate, targetsPtr, TARGET_FREQUENCIES.length, SENSITIVITY, liveFreqPtr);
                if (detectedAmplitude > 0) {
                    const detectedFreq = wasmModule.getValue(liveFreqPtr, 'float');
                    if ('vibrate' in navigator) navigator.vibrate(100);
                    detectionLog.unshift({ time: new Date(), freq: detectedFreq, amp: detectedAmplitude, heading: currentHeading });
                    if (detectionLog.length > 50) detectionLog.pop();
                    updateLogUI();
                    drawRadar();
                }
            }
            
            function showAnalysisModal() {
                analysisModal.style.display = 'flex';
                drawSpectrogram();
                peakInfo.style.display = 'none';
                spectrogramSelector.style.display = 'none';
            }

            function drawSpectrogram() {
                const canvas = spectrogramCanvas, ctx = spectrogramCtx;
                const width = 512, height = 256;
                canvas.width = width; canvas.height = height;
                if (historyBuffer.length === 0) return;
                const step = width / historyBuffer.length;
                for (let i = 0; i < historyBuffer.length; i++) {
                    const dataArray = historyBuffer[i];
                    for (let j = 0; j < dataArray.length; j++) {
                        const value = dataArray[j];
                        if (value > 150) {
                            const percent = j / dataArray.length;
                            const y = height - (percent * height);
                            const hue = 240 - (value / 255) * 240;
                            ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.5)`;
                            ctx.fillRect(i * step, y, step, 1);
                        }
                    }
                }
            }
            
            spectrogramCanvas.addEventListener('click', (event) => {
                const rect = spectrogramCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const timeIndex = Math.floor((x / rect.width) * historyBuffer.length);
                if (timeIndex < 0 || timeIndex >= historyBuffer.length) return;

                spectrogramSelector.style.left = `${x}px`;
                spectrogramSelector.style.display = 'block';

                const selectedData = historyBuffer[timeIndex];
                const maxPeaks = 10;
                const peaksBufferPtr = wasmModule._malloc(maxPeaks * 4);
                wasmModule.HEAPU8.set(selectedData, dataPtr);
                
                const numPeaksFound = wasmModule._find_all_peaks(detectorPtr, dataPtr, analyser.frequencyBinCount, audioContext.sampleRate, SENSITIVITY, peaksBufferPtr, maxPeaks);
                
                selectedSignature = [];
                let peakListHTML = `<div class="italic">${translations[languageSwitcher.value].noPeaks}</div>`;
                if (numPeaksFound > 0) {
                    peakListHTML = '';
                    for (let i = 0; i < numPeaksFound; i++) {
                        const freq = wasmModule.getValue(peaksBufferPtr + i * 4, 'float');
                        selectedSignature.push(freq);
                        peakListHTML += `<div>${(freq / 1000).toFixed(2)} kHz</div>`;
                    }
                }
                wasmModule._free(peaksBufferPtr);
                
                peakListEl.innerHTML = peakListHTML;
                peakInfo.style.display = 'block';
            });

            playSignatureButton.addEventListener('click', () => {
                if (!audioContext || selectedSignature.length === 0) return;
                const now = audioContext.currentTime;
                selectedSignature.forEach(freq => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(freq, now);
                    gainNode.gain.setValueAtTime(0.3 / selectedSignature.length, now);
                    oscillator.start(now);
                    oscillator.stop(now + 0.3);
                });
            });

            trackSignatureButton.addEventListener('click', () => {
                if (selectedSignature.length === 0) return;
                const currentTargets = Array.from(TARGET_FREQUENCIES);
                let newTargetsAdded = false;
                selectedSignature.forEach(freq => {
                    const roundedFreq = Math.round(freq);
                    if (!currentTargets.some(f => Math.abs(f - roundedFreq) < 10)) {
                        currentTargets.push(roundedFreq);
                        newTargetsAdded = true;
                    }
                });

                if (newTargetsAdded) {
                    TARGET_FREQUENCIES = new Float32Array(currentTargets);
                    saveTrackedFrequencies();
                    updateWasmTargets();
                }
                analysisModal.style.display = 'none';
            });

            function updateLogUI() {
                logContainer.innerHTML = '';
                if (detectionLog.length === 0) {
                    logContainer.innerHTML = `<p id="logPlaceholder" class="text-gray-500 text-center pt-4" data-lang="waiting">${translations[languageSwitcher.value].waiting}</p>`;
                    return;
                }
                detectionLog.forEach(entry => {
                    const logEntry = document.createElement('div');
                    logEntry.className = 'bg-gray-700/50 p-2 rounded-md text-sm';
                    const ampPercent = Math.max(0, Math.min(100, ((entry.amp - SENSITIVITY) / (255 - SENSITIVITY)) * 100));
                    const headingText = entry.heading !== null ? `<span class="text-purple-300">${Math.round(entry.heading)}°</span>` : '';
                    logEntry.innerHTML = `
                        <div class="flex justify-between items-center">
                            <span class="font-mono text-xs text-gray-400">${entry.time.toLocaleTimeString()}</span>
                            <span class="font-bold text-blue-300">${(entry.freq / 1000).toFixed(1)} kHz</span>
                            <span class="text-gray-300">Loudness: ${entry.amp}</span>
                            ${headingText}
                        </div>
                        <div class="w-full amp-bar-container rounded-full h-2 mt-1">
                            <div class="amp-bar h-2 rounded-full" style="width: ${ampPercent}%;"></div>
                        </div>
                    `;
                    logContainer.appendChild(logEntry);
                });
            }

            function drawRadar() {
                if (!radarCanvas.isConnected) return;
                const size = radarCanvas.getBoundingClientRect().width;
                radarCanvas.width = size;
                radarCanvas.height = size;
                const center = size / 2;
                const radius = center * 0.9;
                
                radarCtx.clearRect(0, 0, size, size);

                radarCtx.strokeStyle = 'rgba(75, 85, 99, 0.5)';
                radarCtx.fillStyle = 'rgba(156, 163, 175, 0.7)';
                radarCtx.font = `${center * 0.08}px Inter`;
                radarCtx.textAlign = 'center';
                radarCtx.textBaseline = 'middle';

                ['N', 'E', 'S', 'W'].forEach((dir, i) => {
                    const angle = i * Math.PI / 2 - Math.PI / 2;
                    const x = center + (radius * 1.05) * Math.cos(angle);
                    const y = center + (radius * 1.05) * Math.sin(angle);
                    radarCtx.fillText(dir, x, y);
                });
                
                radarCtx.beginPath();
                radarCtx.arc(center, center, radius * 0.8, 0, 2 * Math.PI);
                radarCtx.stroke();
                radarCtx.beginPath();
                radarCtx.arc(center, center, radius * 0.4, 0, 2 * Math.PI);
                radarCtx.stroke();

                detectionLog.forEach((entry, index) => {
                    // Default to North (top) if heading is not available
                    const heading = entry.heading !== null ? entry.heading : 0;
                    const angle = (heading - 90) * Math.PI / 180;
                    const loudnessRatio = Math.max(0, Math.min(1, (entry.amp - SENSITIVITY) / (255 - SENSITIVITY)));
                    const distanceFromCenter = loudnessRatio * radius;
                    
                    const x = center + distanceFromCenter * Math.cos(angle);
                    const y = center + distanceFromCenter * Math.sin(angle);
                    
                    const pointRadius = 2 + loudnessRatio * 4;
                    const opacity = 1 - (index / detectionLog.length);
                    
                    radarCtx.beginPath();
                    const hue = 120 - (loudnessRatio * 120);
                    radarCtx.fillStyle = `hsla(${hue}, 100%, 50%, ${opacity})`;
                    radarCtx.arc(x, y, pointRadius, 0, 2 * Math.PI);
                    radarCtx.fill();
                });
            }

            // Initial Draw
            window.addEventListener('resize', drawRadar);
            drawRadar();
        }

        var Module = { onRuntimeInitialized: function() { startApp(Module); } };
    </script>
    <script src="https://cricket-detector.netlify.app/detector.js" async></script>
</body>
</html>

